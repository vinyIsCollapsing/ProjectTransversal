/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"


// Local functions
static uint8_t SystemClock_Config(void);


int main(void)
{
	uint8_t 	status;
	uint32_t	n;

	uint8_t		msg_sent;

	uint8_t		msg[12] = "I am groot\r\n";


	// Switch to HSE, 216MHz
	while(SystemCoreClock != 216000000)
	{
		status = SystemClock_Config();
		delay_ms(10);
	}

	// Initialize debug console
	BSP_Console_Init();
	my_printf("\n\n\rConsole Ready!\r\n");

	if (status == 0)
	{
		my_printf("System Clock Configuration succeeded\r\n");
		my_printf("SYSCLK = %d\r\n", SystemCoreClock);
	}

	else my_printf("System Clock Configuration failed\r\n");

	// Initialize LEDS pins
	BSP_LED_Init();

	// LED test loop
	for(n=0; n<6; n++)
	{
		BSP_LED_Toggle(LEDN_GREEN);
		delay_ms(100);
		BSP_LED_Toggle(LEDN_BLUE);
		delay_ms(100);
		BSP_LED_Toggle(LEDN_RED);
		delay_ms(100);
	}

	// Initialize User Push-Button
	BSP_PB_Init();

	// Initialize and start USB Core
	BSP_USB_Core_Init();


	// Initialize control flags
	msg_sent = 0;



	while(1)
	{
		// If a terminal is connected on the computer
		if (g_usb.cdc_ready)
		{
			BSP_LED_On(LEDN_BLUE);

			// Print a message into USB console upon user button pressing
			if (BSP_PB_GetState() == 1)
			{
				if (msg_sent == 0)
				{
					BSP_LED_On(LEDN_GREEN);
					BSP_USB_Send(msg, 12);

					my_printf("Sending -> I am groot\r\n");

					msg_sent = 1;

					delay_ms(100);
				}
			}

			else
			{
				BSP_LED_Off(LEDN_GREEN);
				msg_sent = 0;
			}

		}

		// If no terminal is available
		else
		{
			BSP_LED_Off(LEDN_BLUE);
		}
	}

}


/*
 * 	Clock configuration for the Nucleo STM32F746ZG board
 * 	HSE input Bypass Mode 				-> 8MHz
 * 	SYSCLK, AHB							-> 216MHz
 * 	APB1								-> 54MHz  (periph) 108MHz (timers)
 * 	APB2								-> 108MHz (periph) 216MHz (timers)
 *
 */

static uint8_t SystemClock_Config(void)
{
	uint32_t	status;
	uint32_t	timeout;

	// Start HSE
	RCC->CR |= RCC_CR_HSEBYP;
	RCC->CR |= RCC_CR_HSEON;

	// Wait until HSE is ready
	timeout = 1000;

	do
	{
		status = RCC->CR & RCC_CR_HSERDY;
		timeout--;
	} while ((status == 0) && (timeout > 0));

	if (timeout == 0) return (1U);					// HSE error


	// Enable the power regulator scale mode 1
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR1 |= PWR_CR1_VOS;

	// Configure the main PLL
	#define PLL_M	8		// 8MHz HSE down-to 1MHz PLL input
	#define PLL_N	432		// 432 MHz VCO output
	#define PLL_P	2		// 216 MHz PLL output
	#define PLL_Q	9		// 48  MHz (USB)

	RCC->PLLCFGR = PLL_M | (PLL_N <<6) | (((PLL_P >> 1) -1) << 16) | (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

	// Enable the main PLL
	RCC-> CR |= RCC_CR_PLLON;

	// Enter Over-drive power mode
	PWR->CR1 |= PWR_CR1_ODEN;

	// Wait until OD is ready
	timeout = 1000;

	do
	{
		status = PWR->CSR1 & PWR_CSR1_ODRDY;
		timeout--;
	} while ((status == 0) && (timeout > 0));

	if (timeout == 0) return (2U);					// PWR error

	// Switch to OD power supply
	PWR->CR1 |= PWR_CR1_ODSWEN;

	// Wait until supply is switched
	timeout = 1000;

	do
	{
		status = PWR->CSR1 & PWR_CSR1_ODSWRDY;
		timeout--;
	} while ((status == 0) && (timeout > 0));

	if (timeout == 0) return (2U);					// PWR error


	// Configure Flash ART accelerator, prefetch and wait state (increase wait states at 216 MHz)
	FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_4WS;

	// Configure AHB/APB prescalers
	// AHB  Prescaler = /1	-> 216 MHz
	// APB1 Prescaler = /4  -> 54  MHz
	// APB2 Prescaler = /2  -> 108 MHz
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;

	// Wait until PLL is ready
	timeout = 1000;

	do
	{
		status = RCC->CR & RCC_CR_PLLRDY;
		timeout--;
	} while ((status == 0) && (timeout > 0));

	if (timeout == 0) return (3U);			// PLL error


	// Select the main PLL as system clock source
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_PLL;

	// Wait until PLL is switched on
	timeout = 1000;

	do
	{
		status = RCC->CFGR & RCC_CFGR_SWS;
		timeout--;
	} while ((status != RCC_CFGR_SWS_PLL) && (timeout > 0));

	if (timeout == 0) return (4U);			// SW error

	// Update System core clock
	SystemCoreClockUpdate();
	return (0);
}


